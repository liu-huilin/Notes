## AcWing

### 1. 基础算法

#### 快速排序

```c++
/*
步骤：
1、取分界点x(数组中的值)
2、左右区间交换值
3、递归
时间复杂度：O(NlongN)
*/
void quick_sort(int q[], int l, int r)
{
    if(l >= r)
        return;
    int i = l - 1, j = r + 1, x = q[(l + r) >> 1];
    while(i < j)
    {
        while(q[++i] < x);
        while(q[--j] > x);
        if(i < j)
            swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
/*作者：yxc
链接：https://www.acwing.com/blog/content/277/
来源：AcWing*/
```



#### 归并排序

```c++
/*
步骤：
1、取分界点mid(下标)
2、左右两边递归排序
3、左右合并
时间复杂度：O(NlongN)
*/
void merge_sort(int q[], int temp[], int l, int r)
{
    if(l >= r)
        return;
    int mid = (l + r) >> 1;
    merge_sort(q, l, mid); // 递归
    merge_sort(q, mid + 1, r);
    int k = 0, i = l, j = mid + 1;
    while(i <= mid && j <= r) // 排序
    {
        if(q[i] <= q[j])
            temp[k++] = q[i++];
        else
            temp[k++] = q[j++];
    }
    while(i <= mid)
        temp[k++] = q[i++];
    while(j <= r)
        temp[k++] = q[j++];
    //归并
    for(i = l, j = 0; i <= r; i++, j++)
        q[i] = temp[j];
}
```



#### 二分

##### 整数二分

```c++
bool check(int x); // 检查x是否满足某种性质
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用
int bserach_1(int l, int r)
{
    while(l < r)
    {
        int mid = (l + r) >> 1;
        if(check(mid)) 
            r = mid;
        else
            l = mid + 1;
    }
    return l;
}

// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bserach_2(int l, int r)
{
    while(l < r)
    {
        int mid = (l + r + 1) >> 1;
        if(check(mid))
        	l = mid;
       	else
            r = mid - 1;
    }
    return l;
}
```

##### 浮点数二分

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_f(double l, double r)
{
    const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求
    while(r - l > eps)
    {
        double mid = (l + r) / 2;
        if(check(mid))
            r = mid;
       	else
            l = mid;
    }
    
    return l;
}
```

#### 大数加法

```c++
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) 
        return add(B, A);

    vector<int> C;
    int t = 0; // t表示进位
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) 
            t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
	if (t) 
        C.push_back(t);
   	
    return C;
}
```

#### 大数减法

```c++
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t; // t 表示借位
        if (i < B.size()) 
            t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) 
            t = 1;
        else 
            t = 0;
    }
    // 去除前导0
    while (C.size() > 1 && C.back() == 0) 
        C.pop_back();
    
    return C;
}
```

#### 大数乘法

```c++
// C = A * b, A >= 0, b >= 0，A是大数
vector<int> mymul(vector<int>& A, int b)
{
    if(b == 0)
        return {0};
    if(b == 1)
        return A;
    vector<int> C;
    int t = 0; // t是进位
    for(int i = 0; i < A.size() || t != 0; i++)
    {
        if(i < A.size())
            t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    
    return C;
}
```



#### 大数除法

```c++

```











## Other

数位DP

```
https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/
```

染色法

```
https://leetcode.cn/problems/possible-bipartition/
```

