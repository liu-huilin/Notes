## 数据结构

**定义**：数据结构是计算机中储存、组织数据的方式。

### 线性表

由同类型数据元素构成的有序列表的线性结构

#### 基本操作

- 初始化
- 根据索引返回相应的元素
- 在线性表中查找元素X第一次出现的位置
- 在指定位置插入元素
- 删除指定元素
- 返回线性表的长度

#### 储存方式

- 数组实现（连续空间）
- 链表实现（非连续空间）



#### 链表

链表是一种逻辑上连续，储存上分散的线性表，其基本单位为结点，每个结点分数据区和指针区，指针区指向其他结点。链表的优势在于插入和删除快，储存空间利用率高，缺点是索引慢。

##### 基本操作

- 初始化
- 根据索引返回相应的元素
- 插入
- 删除
- 查找

##### 单链表

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/list1.png)

单链表每个结点包含一个指针，该指针指向下一个结点，因此单链表不能”回头“

##### 双链表

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/list2.png)

双链表每个结点有两个指针，一个指向上一个结点，一个指向下一个结点，因此双链表支持前向、后向查询。

##### 循环链表

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/list3.png)

循环链表是首尾相连的链表。

#### 堆栈

具有一定操作约束的线性表，只能在一端（栈顶，top）进行插入删除操作，并且无法遍历，是一种后入先出（Last In First Out）的结构。

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/clip_image002-1547604555425.jpg)

##### 基本操作

- 入栈（push），往栈中压入数据
- 出栈（pop），删除并返回栈顶元素
- 生成空堆栈
- 判断堆栈是否满
- 判断堆栈是否为空

#### 队列

具有一定操作约束的线性表，只能在一端插入（队尾），而在另一端删除（队头），是一种先进先出（First In First Out）的结构。

##### 基本操作

- 生成空队列
- 判断队列是否满
- 判断队列是否为空
- 在队尾插入数据
- 删除队头元素并返回

##### 顺序储存实现

队列的顺序储存通常由一个一维数组和一个记录队列头元素位置的变量front和记录队列尾部元素位置的变量rear组成。

但是这种队列会造成空间的浪费，当队头被删除后，前面的空间就被浪费了，使用循环链表可以解决这个问题。

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/quene.png)

##### 循环队列

循环队列只是逻辑上的循环，实际也可以通过数组实现，front和rear的移动通过“加1取余”法，如此就可以实现逻辑上的循环。

```c++
// 队列插入 伪代码
void add_queue(int val)
{
	if((q->real + 1)%q->max_size == q->front)
	{
		cout << "队列满" << endl;
	}
	q->rear = (q->real + 1)%q->max_size; // 队尾移动
	q->data[q->real] = val;
}
```

front与rear相等时队列为空。

##### 队列的链式储存

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/queue_list.png)



### 树

#### 基础知识

##### 定义

树是n个节点构成的有限集合，当n=0时称为空树，对于如任何一个非空树，它具备如下的性质

- 树中有一个称为**根**的特殊结点
- 其余节点可以分为m(m>0)个互不相交的有限集合，每个集合本身又是一棵树，这些树称为原来树的**子树**

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/tree1.png)

- 具有n个结点的树有n-1条边
- 除了根结点外，每个节点有且只有一个父结点



##### 基本术语

- 结点的度：结点的子树个数
- 树的度：树中所有结点中最大的度数
- 叶结点：度为0的结点
- 父结点：有子树的结点是其子树的根结点的父结点
- 子结点：若A是B的父结点，则B是A的子结点
- 兄弟结点：具有同一父结点的各个结点彼此是兄弟结点
- 结点的层次：规定根结点在1层，其他任一结点的层数是其父结点的层数加1
- 树的深度：树中所有结点的最大层次是树的深度

##### 实现方式

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/tree2.png)

树的实现方式通常使用如上图所示的”儿子兄弟表示法“，即每个数的结点都包含一个数据区和两个指针区域，其中一个指针指向子结点，一个指针指向兄弟结点

#### 二叉树

二叉树是一种特殊的树，其中的每个结点最多有两个子节点，结点有左右之分。

二叉树有五种基本形态

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/binary_tree.png)

##### 满二叉树

除了叶节点，每个结点都有两个字节点的二叉树

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/binary_tree2.png)

##### 完全二叉树

对树的节点从上往下、从左往右进行编号，编号为i的结点与满二叉树中编号为i的结点的位置相同的树称为完全二叉树（Complete Binary Tree），也就是说完全二叉树是满二叉树从最深的一层从右往左连续删除部分结点得到的。

##### 斜二叉树

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/binary_tree3.png)



##### 二叉树的重要性质

- 第$i$层的最大结点数为$2^{i-1}$，$i\geq1$
- 深度为$k$的二叉树有最大结点总数为$2^k - 1$，$k \geq 1$
- 对于任何非空二叉树T，若$n_0$表示叶结点的个数，$n_2$是度为2的结点个数，则两者满足关系$n_0 = n_2 + 1$



##### 二叉树的储存结构

- 顺序储存

通常只有完全二叉树使用该方式储存，将结点从上到下、从左到右编号，然后按编号将二叉树储存在数组中。根节点的序号为0，非根节点的父节点的序号是$[i/2]$（取整），结点$i$的左子结点的序号是$2i$，右子结点的序号是$2i+1$，若超出索引则说明不存在对应的子结点。

普通二叉树使用此方法会浪费空间，因此通常不用此方法

- 链式储存

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/binary_tree4.png)

每个结点由数据区和两个指针组成，两个指针分别指向左子结点和右字结点。

##### 二叉树遍历

遍历规则：

- 先序：根、左子树、右子树
- 中序：左子树、根、右子树
- 后序：左子树、右子树、根
- 层次遍历：从上往下，从左往右

遍历方法：

- 递归实现
- 队列实现
- 堆栈实现

#### 二叉搜索树

##### 定义

满足如下性质的非空二叉树为二叉搜索树（Binary Search Tree）：

- 非空左子树的所有键值小于其根结点的键值
- 非空右子树的所有键值大于其根结点的键值
- 左右子树都是二叉搜索树

![](https://gitee.com/liu-huilin/markdownimg/raw/main/img2022/note_binary_search_tree1.png)



##### 基本操作

- 查找元素
- 查找最小元素
- 查找最大元素
- 插入
- 删除

### 图

#### 基础定义

图：图是由**顶点**的有穷非空集合和顶点之间的**边**的集合组成，通常表示为G(V, E)，G表示一个图，V是图G中的顶点的集合，E是图G中边的集合。

无向边：若顶点a和b之间的边没有方向，则称该边为无向边（Edge）。

无向图：若途中任意两个顶点之间的边都是无向边，则该图为无向图（Undirected graphs）。

有向边：若从顶点a到b的边有方向，则称该边为有向边，也称为弧（Arc）。





## 算法

### 基础知识

**时间复杂度**：算法运行的常数操作次数的表达式的最高阶项，按**最坏的情况**计算，时间复杂度N记作O(N)

**空间复杂度**：根据算法写出的程序在执行时占用的储存单元的长度，记作S(N)

### 查找算法

- 静态查找：集合中的数据是固定不变的，没有插入和删除操作，只有查找
- 动态查找：集合中的数据是动态变化的，除了查找还可能发生插入和删除

#### 二分查找

使用二分查找的前提是数据**有序**

时间复杂度O(logN)

```c++
void list::binary_search(int value)
{
    int left, right, mid;
   	left = 0; // 初始左边界
    right = self->length; // 初始右边界，list的长度
    while(left <= right)
    {
        mid = (left + right)/2;
        if(value < this->data[mid])
            right = mid - 1; // 调整右边界
        else if(value > this->data[mid])
            left = mid + 1; // 调整左边界
        else if(value == this->data[mid])
            return mid; // 查找成功，返回数据元素的下标
    }
    return -1; // 查找不成功，返回-1
}
```



### 排序算法

