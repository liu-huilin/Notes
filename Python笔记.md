# Python菜鸟笔记

### Python基础语法

```python
print(r"Hello\n") # 使用r使\不转义
```

print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **end=""**

```python
# 不换行输出
print( x, end=" " )
print( y, end=" " )
```

Python 通常是一行写完一条语句，但如果语句很长，可以使用反斜杠 \ 来实现多行语句

Python 可以在同一行中使用多条语句，语句之间使用分号 **;** 分割

#### 基本数据类型

Python3有六个标准的数据类型

##### 不可变类型：

- **数字**：int、float、bool、complex（复数的实部和虚部都是浮点型），Python3 中，只有一种整数类型 int，表示为长整型，bool 是 int 的子类，True 和 False 可以和数字相加。
- **字符串（str）**：Python 没有单独的字符类型，一个字符就是长度为1的字符串。Python 字符串不能被改变，向一个索引位置赋值，比如word[0] = 'm'会导致错误。
- **元组（tuple）**：元组中只包含一个元素时，需要在元素后面添加逗号 ，否则括号会被当作运算符使用。

##### 可变类型：

- **列表（list）**：
- **集合（set）**：可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() ，集合的元素是**无序**且**不重复**的。集合可以进行交、并、差、补等操作。
- **字典（dict）**：**无序**，在同一个字典中，键(key)必须是**唯一**且不可变的，{ }可以创建一个空字典。



type(a)可以查询变量a所指的对象类型，isinstance(a, int)可以判断a所指的对象是否是int类型。

isinstance 和 type 的区别在于：type()不会认为子类是一种父类类型，isinstance()会认为子类是一种父类类型。

#### 运算符

&：按位与

|：按位或

^：按位异或

~：按位取反

<<：左移

\>>：右移

#### 循环

**while 循环使用 else 语句**

如果 while 后面的条件语句为 false 时，则执行 else 的语句块。

语法格式如下：

```python
while <expr>:
    <statement(s)>
else:
    <additional_statement(s)>
```



#### 函数

**函数文档**：写在函数开头，放在括号里，调用函数的\_\_doc\_\_（）方法可以访问函数文档，或者使用help方法。

python支持**函数嵌套**，但作用域仅在其上一级函数内。

**global**：声明变量为全局变量

**nonlocal**：声明不创建局部变量，主要用于函数嵌套中

```python
def f1():
    x = 5
    def f2():
        nonlocal x
        x *= x
        return x
    return f2()
```



**闭包**：

闭包（closure）定义为如果在一个内部函数里对外部作用域（但不是在全局作用域） 的变量进行引用，内部函数就被认为是闭包，如：

```python
def funx(x):
    def funy(y):
        return x * y
    return funy

f = funx(3)
print(f)
print(f(4))
```

闭包可以保存当前的运行环境。



**匿名函数**

```python
lambda x : 2*x + 1
```

lambda （参数）：（返回值）



**内置函数**（BIF，Built-in Functions）

filter

```python
filter(function or None, iterable)
# 第一个参数是函数对象或None，第二个函数是可迭代对象
# 返回值是一个可迭代对象
# 如果第一个参数是函数，将第二个参数的值作为参数输入函数，返回让函数值为True的值
# 如果第一个参数是None，返回第二个参数中为True的值

# 例程
list(filter(lambda x : x%2, range(10)))

# ---运行结果---
[1, 3, 5, 7, 9]
```

map

```python
map(func, *iterables)
# 第一个参数为函数，第二个参数为可迭代对象
# 返回值是一个可迭代对象
# 将第二个参数作为输入，返回func函数的所示输出

# 例程
list(map(lambda x : x*2, range(10)))

# ---运行结果---
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```



#### 文件操作

| 模式 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| t    | 文本模式 (默认)。                                            |
| x    | 写模式，新建一个文件，如果该文件已存在则会报错。             |
| b    | 二进制模式。                                                 |
| +    | 打开一个文件进行更新(可读可写)。                             |
| r    | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 |
| rb   | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 |
| r+   | 打开一个文件用于读写。文件指针将会放在文件的开头。           |
| rb+  | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 |
| w    | 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |
| wb   | 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 |
| w+   | 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |
| wb+  | 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 |
| a    | 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| ab   | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| a+   | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 |
| ab+  | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 |



#### 异常

**断言**

assert，用于判断一个表达式，表达式值为false时触发异常

**异常处理**

```python
try:
	# 执行代码
except E [as e]:
	# 发生异常时执行的代码
```



```python
try:
	# 执行代码
except E [as e]:
	# 发生异常时执行的代码
else：
	# 没有异常时执行的代码
```



```python
try:
	# 执行代码
except E [as e]:
	# 发生异常时执行的代码
else：
	# 没有异常时执行的代码
finally:
    # 无论是否发生异常，都会执行的代码
```



### 面向对象

#### 基本知识

**类**：

**类对象**：

**实例对象**：

类属性

实例属性



面向对象的特征：**封装、继承、多态**，多态指不同对象对同一方法响应不同的行动。



Python定义**私有**成员只需要要变量名或函数名前加上两个下划线“\_\_”，这个变量或函数就会变成私有的。但是这种私有是**伪私有**的，其实只是解释器将“\_\_”开头的成员改名，变成了\_classname\_\_name。



如果子类定义了与父类同名的方法，子类方法会覆盖父类方法，这叫**方法的重写**。



 子类调用父类构造函数的方法

```python
# 1、调用未绑定的父类方法
baseclass.__init__() 

# 2、使用super函数
super().__init__() 
```

推荐使用第二种方法，可以自动调用所有父类的构造函数，多继承时使用非常方便。



self代表类的实例（对象），而非类，但是self并不是Python的关键字，只是约定俗成写为self。



Python同样有限的支持**多继承**形式。多继承的类定义形如下例:

```python
class DerivedClassName(Base1, Base2, Base3):    
    <statement-1>    
    .    
    .    
    .    
    <statement-N>
```

需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。



**类的专有方法**：
\_\_init\_\_ : 构造函数，在生成对象时调用
\_\_del\_\_ : 析构函数，释放对象时使用
\_\_repr\_\_: 打印，转换
\_\_setitem\_\_ : 按照索引赋值
\_\_getitem\_\_: 按照索引获取值
\_\_len\_\_: 获得长度
\_\_cmp\_\_: 比较运算
\_\_call\_\_: 函数调用
\_\_add\_\_: 加运算，通过重写这个方法可以实现**运算符重载**，下同
\_\_sub\_\_: 减运算
\_\_mul\_\_: 乘运算
\_\_truediv\_\_: 除运算
\_\_mod\_\_: 求余运算
\_\_pow\_\_: 乘方







 



**@staticmethod**

声明类的静态方法，不实例化类也可调用该方法。

```python
class C(object):
    @staticmethod
    def f():
        print('runoob');
 
C.f();          # 静态方法无需实例化
cobj = C()
cobj.f()        # 也可以实例化后调用
```

**@abstractmethod**

声明类的抽象方法，含抽象方法的类不能被实例化，其子类必须复写所有的抽象方法